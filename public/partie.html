<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partie</title>
    <!--
    <style>
        body { margin: 0; overflow: hidden; background: #222; }
        canvas { display: block; background: #333; }
    </style>
    -->
    <link rel="stylesheet" href="game_style.css" />

</head>
<body>
    <div id="menu">
        <h2>Rejoindre une partie</h2>
        <input id="partieId" placeholder="Nom de la partie" />
        <select id="mapSelect">
            <option value="map1">Map 1</option>
            <option value="map2">Map 2</option>
        </select>
        <button id="joinBtn">Rejoindre</button>
    </div>


    <canvas id="c"></canvas>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");
        canvas.width = 800;
        canvas.height = 600;

        const menu = document.getElementById("menu");
        const joinBtn = document.getElementById("joinBtn");
        const partieInput = document.getElementById("partieId");
        const mapSelect = document.getElementById("mapSelect");

        const socket = io();

        const keys = {
            left: false,
            right: false
        };

        let joueurs = {};
        let colliders =[];
        let joined =false; 

        socket.on("connect", () => console.log("Socket.IO connecté", socket.id));
        socket.on("connect_error", (err) => console.error("Erreur connexion", err));

        // Réception des colliders (map) - On attend activement que le serveur envoie
        socket.on("map", (data) => { 
            colliders = data; 
        });

        // Réception état des joueurs
        socket.on("state", (data) => { 
            joueurs = data;
        });

        // Bouton rejoindre
        joinBtn.addEventListener("click", () => {
            const partieId = partieInput.value.trim();
            const mapId = mapSelect.value;

            if (!partieId) {
                alert("Entre un nom de partie");
                return;
            } 
            socket.emit("join", { partieId, mapId });

            menu.style.display = "none";
            canvas.style.display = "block";
            joined = true;
        });
        



        // Actions clavier
        document.addEventListener("keydown", (e) => {
            if (e.repeat) return;

            if (e.key === "ArrowLeft" && !keys.left) {
                  keys.left = true;
                  socket.emit("action", "left");
            }

            if (e.key === "ArrowRight" && !keys.right) {
                keys.right = true;
                socket.emit("action", "right");
            }

            if (e.key === " " || e.key === "ArrowUp") {
                socket.emit("action", "jump");
            }
        });

        document.addEventListener("keyup", (e) => {
            if (e.key === "ArrowLeft") {
                keys.left = false;
                socket.emit("action", "stopLeft");
            }

            if (e.key === "ArrowRight") {
                keys.right = false;
                socket.emit("action", "stopRight");
            }
        });

        // Dessin
        function loop() {
            if (!joined) return requestAnimationFrame(loop);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // dessiner tous les joueurs
            for (const id in joueurs) {
                const p = joueurs[id];
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                ctx.fillStyle = id === socket.id ? "orange" : "blue";
                ctx.fillRect(-20, -20, 40, 40);
                ctx.restore();
            }

            // dessiner les colliders
            ctx.fillStyle = "grey";
            for (const c of colliders) {
                ctx.fillRect(
                    c.x - c.width / 2,
                    c.y - c.height / 2,
                    c.width,
                    c.height
                );
            }

            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>
